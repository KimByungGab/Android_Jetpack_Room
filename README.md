간단한 룸을 제작해보았다.

전에 라이브데이터와 뷰바인딩을 사용했었는데 이제 한 단계 더 들어가 리포지터리를 이용하여 Room을 이용해보기로 했다.
Room을 가장 먼저 찾아보니 Developer 사이트에 Room에 대해 자세히 나와있었고 권장도 하고 있었다.

기본적으로 Room을 이용하면서 SQLiteDBHelper와 생각을 해 봤을 때, 좀 더 DB를 사용하기 편한 면은 있었다.
기존의 DBHelper 클래스를 만들고 SQL문을 실행하는 메소드를 만들게 되면 여러 상용구를 사용하게 되지만, DAO를 사용하면서 어노테이션으로 쿼리를 넣기 때문에 한번에 어떤 쿼리를 실행시키는지 빠르게 캐치할 수 있었다.

사용법으로서는 그렇게 구분을 지어 사용하는 것 말고는 따로 불편한 점은 없는 것 같다. 마치 HttpUrlConnection은 극대화된 커스텀이 장점이지만 하나하나 해줘야 할 것이 많은 것처럼.

하지만 성능의 이야기라면 다르다.

Room은 SQLite에서 한층 더 강화되어 SQLite에 추상화 계층을 하나 더 추가시켜 DB접근을 단순화하고 상용구를 줄이고 SQL 쿼리의 유효성을 검사하는 라이브러리이다.

SQLite의 문제점은 여러가지가 있는데
  1. SQL 쿼리에 대한 컴파일 체크가 없다. 실제로 DB에 틀린 컬럼을 작성하고 실행시켜도 런타임동안 예외가 발생되고 컴파일 하는 동안에는 잡을 수가 없다.
  2. 스키마가 바뀌면 영향 받는 SQL을 수동 업데이트 시켜줘야한다. 여기서 시간이 오래 걸리거나 다른 오류가 발생할 수 있다.
  3. SQL쿼리와 데이터 객체간의 변환 처리를 하려면 많은 상용구를 넣어줘야한다.
로 꼽을 수가 있다.

여기서 Room의 장점이 이를 커버시켜 준다.
Room의 장점은
  1. 컴파일하는 시간에 SQL 유효성 검사를 한다.
  2. 스키마가 바뀌었을 때 직접 SQL 쿼리를 바꾸지 않아도 된다.
  3. 상용구 코드 없이 자바 객체와 DB를 맵핑한다.
  4. LiveData 혹은 RxJava와도 같이 사용할 수 있다.
  
마지막 장점을 빼고서는 SQLite의 단점을 모두 보완한다. 더 깊이 생각해서 이런 장점들을 잘 챙길 수 있는 때는 역시 사이즈가 크게 될 때인 것 같다. 사이즈가 클 때 하나하나가 요소가 될 텐데, SQL 유효성 검사부터, 스키마가 바뀔때도 SQL 쿼리를 바꾸지 않아도 된다고 하면 확실히 판이 커지면 커질수록 더욱 큰 이점이다.

물론 상황과 기호에 맞춰 사용하면 되지만 안드로이드 공식 개발자 문서에서는 Room을 적극 권장하고 있으니 한번 사용해보면 좋을 것이다. 실제로도 구조화된 느낌이 든다. 점점 프레임워크화 되는 것 같기도 하다. ㅋㅋ

대신에 Room을 사용하면서 서브쓰레드를 빼놓지 않을 수가 없다. Room을 작동시키려고 하는데 메인쓰레드에서는 작동을 못 시키더라. 아예 Room 자체가 예외를 뿜어내고 바쁘니까 서브쓰레드에서 해. 라고 언급한다.

내가 코루틴을 알았더라면....(참고로 쓰레드 신봉자다...)

때문에 기존에 했던 대로 쓰레드를 사용하고 post를 사용해서 서브쓰레드에서 핸들링을 하여 UI 작업을 수행하였다.

구글에 좀 더 찾아보니까 기존에 하는 쓰레드와 다르게 코루틴이 좀 더 성능이 좋다고 한다. 쓰레드보다 간결해서 코드를 짜기 편했다는 개발자분들도 적지 않았다. (하긴... UI 작업을 하기 위해서 결과값을 핸들러 통해서 메시지 전달하고 핸들러에서 UI 작업 수행하려고 하는 것을 하면 귀찮긴 하더라... 하나 작업하기 위해서 다른 곁다리 친구들이 더 늘어나는 것도 많고... 배보다 배꼽이 큰 기분도 적잖이 든다.)

때문에 이번에는 코루틴을 이용해보려고 한다.

하지만 코루틴을 이용하는 것이기 때문에 따로 MVVM일 필요 없이 그냥 코루틴으로 코딩만 해서 사용법을 익히려고 한다.
